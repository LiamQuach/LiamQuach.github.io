{
  "hash": "160f9c896b5ac6a9c194e553ca1cb2b0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lab 6 - Spicy\"\ndescription: \"Performing Many Different Versions of an Analysis\"\nimage: image.jpg\nauthor:\n  - name: Liam Quach\n    url: https://LiamQuach.github.io/\n    affiliation: Master of Science in Statistics @ Cal Poly\ndate: 05-04-2025\ncategories: [Quarto, R] # self-defined categories\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\nexecute: \n  echo: true\n  warning: false\n---\n\n\n\n# Setting the Stage\n\nMy number one use case for writing functions and iteration / looping is to\nperform some exploration or modeling repeatedly for different \"tweaked\"\nversions. For example, our broad goal might be to fit a linear regression model\nto our data. However, there are often multiple choices that we have to make in\npractice:\n\n* Keep missing values or fill them in (imputation)?\n* Filter out outliers in one or more variables?\n\nWe can map these choices to **arguments** in a custom model‑fitting function:\n\n* `impute`: TRUE or FALSE\n* `remove_outliers`: TRUE or FALSE\n\nA function that implements the analysis and allows for variation in these\nchoices:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(df, impute, remove_outliers, mod) {\n  if (impute) {\n    df <- some_imputation_function(df)\n  }\n  \n  if (remove_outliers) {\n    df <- function_for_removing_outliers(df)\n  }\n  \n  lm(mod, data = df)\n}\n```\n:::\n\n\n\n---\n\n# Helper Functions\n\n**Exercise 1:** Write a function that removes outliers in a dataset. The user\nshould be able to supply the dataset, the variables to remove outliers from, and\na threshold on the number of SDs away from the mean used to define outliers.\n*Hint 1: You will need to calculate a z‑score to filter the values!*\n*Hint 2: You might want to consider specifying a default value (e.g., 3) for\n`sd_thresh`.*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nremove_outliers <- function(df, ..., sd_thresh = 3) {\n  # Identify numeric columns in the dots\n  supplied_vars  <- names(df %>% select(...))\n  numeric_vars   <- names(df %>% select(...) %>% select(where(is.numeric)))\n  non_numeric    <- setdiff(supplied_vars, numeric_vars)\n  if (length(non_numeric) > 0) {\n    warning(\n      \"The following variables are not numeric and were ignored: \",\n      paste(non_numeric, collapse = \", \")\n    )\n  }\n\n  df %>%\n    mutate(across(all_of(numeric_vars),\n      ~ (. - mean(., na.rm = TRUE)) / sd(., na.rm = TRUE),\n      .names = \"{.col}_z\"\n    )) %>%\n    filter(if_all(ends_with(\"_z\"), ~ abs(.) <= sd_thresh)) %>%\n    select(-ends_with(\"_z\"))\n}\n```\n:::\n\n\n\n## Testing Your Function!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nremove_outliers(diamonds, price, x, y, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,689 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,679 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nremove_outliers(diamonds, price, color)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,734 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,724 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default sd_thresh\nremove_outliers(diamonds, price, x, y, z, sd_thresh = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50,099 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 50,089 more rows\n```\n\n\n:::\n:::\n\n\n\n---\n\n**Exercise 2:** Write a function that imputes missing values for numeric\nvariables in a dataset. The user should be able to supply the dataset, the\nvariables to impute values for, and a function to use when imputing.\n*Hint 1: You will need to use `across()` to apply your function, since the user\ncan input multiple variables.*\n*Hint 2: The `replace_na()` function is helpful here!*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimpute_missing <- function(df, ..., impute_fun = mean) {\n  supplied_vars  <- names(df %>% select(...))\n  numeric_vars   <- names(df %>% select(...) %>% select(where(is.numeric)))\n  non_numeric    <- setdiff(supplied_vars, numeric_vars)\n  if (length(non_numeric) > 0) {\n    warning(\n      \"The following variables are not numeric and were ignored: \",\n      paste(non_numeric, collapse = \", \")\n    )\n  }\n\n  df %>%\n    mutate(across(all_of(numeric_vars),\n      ~ replace_na(., impute_fun(., na.rm = TRUE))\n    ))\n}\n```\n:::\n\n\n\n## Testing Your Function!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nimpute_missing(nycflights13::flights, arr_delay, dep_delay)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nimpute_missing(nycflights13::flights, arr_delay, carrier)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default impute_fun\nimpute_missing(nycflights13::flights, arr_delay, dep_delay, impute_fun = median)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n---\n\n# Primary Function\n\n**Exercise 3:** Write a `fit_model()` function that fits a specified linear\nregression model for a specified dataset. The function should:\n\n* allow the user to specify if outliers should be removed (`TRUE` or `FALSE`)\n* allow the user to specify if missing observations should be imputed\n  (`TRUE` or `FALSE`)\n\nIf either option is `TRUE`, your function should call your `remove_outliers()`\nor `impute_missing()` functions to modify the data **before** the regression\nmodel is fit.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(df, mod_formula,\n                      remove_outliers = FALSE,\n                      impute_missing  = FALSE,\n                      ...) {\n  if (remove_outliers) df <- remove_outliers(df, ...)\n  if (impute_missing)  df <- impute_missing(df, ...)\n  lm(mod_formula, data = df)\n}\n```\n:::\n\n\n\n## Testing Your Function!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model(\n  diamonds,\n  mod_formula     = price ~ carat + cut,\n  remove_outliers = TRUE,\n  impute_missing  = TRUE,\n  price, carat\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mod_formula, data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2460.16      7526.96      1059.65      -410.54       295.80        82.62  \n```\n\n\n:::\n:::\n\n\n\n---\n\n# Iteration\n\nIn the `diamonds` dataset, we want to understand the relationship between\n`price` and size (`carat`). We want to explore variation along two choices:\n\n1. The variables included in the model. We'll explore 4 sets of variables:\n\n   * No further variables (just `price` and `carat`)\n   * Adjusting for `cut`\n   * Adjusting for `cut` and `clarity`\n   * Adjusting for `cut`, `clarity`, and `color`\n2. Whether or not to impute missing values\n3. Whether or not to remove outliers in the `carat` variable (defined as cases\n   whose `carat` is over 3 SDs away from the mean).\n\n## Parameters\n\nFirst, we need to define the set of parameters we want to iterate the\n`fit_model()` function over. The `tidyr` package has a useful function called\n`crossing()` that is useful for generating argument combinations. For each\nargument, we specify all possible values for that argument and `crossing()`\ngenerates all combinations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds_arg_combos <- tidyr::crossing(\n  mod_formula = c(\n    price ~ carat,\n    price ~ carat + cut,\n    price ~ carat + cut + clarity,\n    price ~ carat + cut + clarity + color\n  ),\n  impute_missing  = c(TRUE, FALSE),\n  remove_outliers = c(TRUE, FALSE)\n)\n\ndiamonds_arg_combos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 3\n   mod_formula impute_missing remove_outliers\n   <list>      <lgl>          <lgl>          \n 1 <formula>   FALSE          FALSE          \n 2 <formula>   FALSE          TRUE           \n 3 <formula>   TRUE           FALSE          \n 4 <formula>   TRUE           TRUE           \n 5 <formula>   FALSE          FALSE          \n 6 <formula>   FALSE          TRUE           \n 7 <formula>   TRUE           FALSE          \n 8 <formula>   TRUE           TRUE           \n 9 <formula>   FALSE          FALSE          \n10 <formula>   FALSE          TRUE           \n11 <formula>   TRUE           FALSE          \n12 <formula>   TRUE           TRUE           \n13 <formula>   FALSE          FALSE          \n14 <formula>   FALSE          TRUE           \n15 <formula>   TRUE           FALSE          \n16 <formula>   TRUE           TRUE           \n```\n\n\n:::\n:::\n\n\n\n## Iterating Over the Parameters\n\nWe've arrived at the final step!\n\n**Exercise 5:** Use `pmap()` from `purrr` to apply the `fit_model()` function to\nevery combination of arguments from `diamonds`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_results <- diamonds_arg_combos %>%\n  mutate(model = purrr::pmap(\n    list(mod_formula, impute_missing, remove_outliers),\n    ~ fit_model(\n        diamonds,\n        mod_formula     = ..1,\n        impute_missing  = ..2,\n        remove_outliers = ..3,\n        price, carat\n      )\n  ))\n\nmodel_results\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 4\n   mod_formula impute_missing remove_outliers model \n   <list>      <lgl>          <lgl>           <list>\n 1 <formula>   FALSE          FALSE           <lm>  \n 2 <formula>   FALSE          TRUE            <lm>  \n 3 <formula>   TRUE           FALSE           <lm>  \n 4 <formula>   TRUE           TRUE            <lm>  \n 5 <formula>   FALSE          FALSE           <lm>  \n 6 <formula>   FALSE          TRUE            <lm>  \n 7 <formula>   TRUE           FALSE           <lm>  \n 8 <formula>   TRUE           TRUE            <lm>  \n 9 <formula>   FALSE          FALSE           <lm>  \n10 <formula>   FALSE          TRUE            <lm>  \n11 <formula>   TRUE           FALSE           <lm>  \n12 <formula>   TRUE           TRUE            <lm>  \n13 <formula>   FALSE          FALSE           <lm>  \n14 <formula>   FALSE          TRUE            <lm>  \n15 <formula>   TRUE           FALSE           <lm>  \n16 <formula>   TRUE           TRUE            <lm>  \n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}